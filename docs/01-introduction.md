# 第一篇：初识 Brainfuck 与项目架构

欢迎来到 BFCompiler 项目！如果你刚学完 C/C++ 的基础语法（比如指针、数组、循环），并且对"编译器是怎么工作的"感到好奇，那么这个项目就是为你量身定做的。

在这个系列教程中，我们将一起探索如何把一段看似乱码的符号，变成能真正在你的电脑上跑起来的 `.exe` 文件。

## 1. 什么是 Brainfuck？

Brainfuck（简称 BF）是一种极简的编程语言。它到底有多极简？它只有 **8 个字符** 作为有效指令：`> < + - . , [ ]`。代码里其他的任何字符（比如空格、换行、字母）都会被当作注释，直接忽略。

虽然它看起来像乱码，比如输出 "Hello World" 的程序长这样：
```bf
++++++++[>++++[>++>+++>+++>+<<<<-]>+>+>->>+[<]<-]>>.>---.+++++++..+++.>>.<-.<.+++.------.--------.>>+.>++.
```

但它其实是**图灵完备**的。意思是，只要给你足够的时间和内存，任何 C 语言能写的逻辑，理论上都能用这 8 个符号写出来！

### 把 BF 翻译成 C 语言

为了理解 BF，你可以把它想象成一台极其简陋的计算机。这台计算机里只有两样东西：
1. **内存带 (Tape)**：一个超级长的字节数组（通常是 30000 个字节），初始值全是 0。
2. **数据指针 (Pointer)**：一个指向内存带某个位置的手指，一开始指着第 0 个格子。

现在，我们把这 8 个符号翻译成你熟悉的 C 语言：

假设我们在 C 语言里这样定义这台计算机：
```c
unsigned char tape[30000] = {0}; // 内存带
unsigned char *ptr = tape;       // 数据指针
```

那么 BF 的 8 条指令对应的 C 代码就是：

| BF 指令 | 含义 | C 语言等价代码 |
| :---: | :--- | :--- |
| `>` | 指针向右移动一格 | `ptr++;` |
| `<` | 指针向左移动一格 | `ptr--;` |
| `+` | 当前格子里的数字加 1 | `(*ptr)++;` |
| `-` | 当前格子里的数字减 1 | `(*ptr)--;` |
| `.` | 打印当前格子的数字（作为 ASCII 字符） | `putchar(*ptr);` |
| `,` | 从键盘读入一个字符存到当前格子 | `*ptr = getchar();` |
| `[` | 如果当前格子是 0，就跳到对应的 `]` 后面 | `while (*ptr) {` |
| `]` | 如果当前格子不是 0，就跳回到对应的 `[` | `}` |

你看，只要你会写 `while` 循环和指针的加减，你就已经完全掌握了 BF 语言的全部语法！

## 2. 为什么需要三个工具？

在这个项目中，我们并没有只写一个程序，而是写了三个不同的工具：**解释器 (Interpreter)**、**转译器 (Transpiler)** 和 **编译器 (Compiler)**。

为什么要做三样东西？因为它们代表了让代码跑起来的三种截然不同的思路，这也是理解编译原理最好的敲门砖。

### 工具一：解释器 (bf-interpreter)
* **思路**：**同声传译**。
* **做法**：解释器是一个 C++ 写的程序，它在自己内部偷偷建了一个 `tape` 数组和一个 `ptr` 指针。然后它逐字读取你写的 `.bf` 文件，看到 `+` 就让自己的数组元素加 1，看到 `.` 就调用自己的 `putchar`。
* **特点**：不用生成任何新文件，直接就能跑出结果，但速度相对较慢（因为每次执行都要做"看到什么符号就做什么动作"的判断）。

### 工具二：转译器 (bf-transpiler)
* **思路**：**文本翻译**。
* **做法**：转译器本身不执行代码，它只负责把 `.bf` 文件里的乱码，原封不动地翻译成标准的 `.c` 源代码文件。
* **特点**：它生成的是给人（或者给其他编译器）看的代码。生成出来的 C 代码，你可以用 `gcc` 编译成极快的可执行文件。这叫 Source-to-Source 编译。

### 工具三：编译器 (bf-compiler)
* **思路**：**直接印小广告**。
* **做法**：这是本项目最硬核的部分！它既不自己执行，也不生成 C 代码，而是**直接生成 CPU 认识的二进制机器码**，并把它打包成 Windows 系统的 `.exe` 文件！
* **特点**：不需要依赖 `gcc`，它自己就是一个小型的 `gcc`。这是真正的"编译"过程。

## 3. 项目的整体目录结构

为了不让代码乱成一锅粥，我们把项目分成了几个明确的文件夹。这是 C++ 中大型项目的标准做法：

```text
BFCompiler/
├── CMakeLists.txt        # 告诉 CMake 怎么编译整个项目
├── common/               # 共享模块（大家都要用的工具箱）
│   ├── include/          # 头文件 (.h)
│   └── src/              # 实现文件 (.cpp)
├── interpreter/          # 解释器的代码
├── transpiler/           # 转译器的代码
├── compiler/             # 编译器的代码
└── tests/                # 用来测试的 BF 程序 (比如 hello.bf)
```

**为什么要有 `common` 文件夹？**
仔细想想，无论是解释、转译还是编译，第一步是不是都要把 `.bf` 文件读进来？是不是都要把没用的空格和注释删掉？是不是都要把括号匹配好？
这些**所有工具都要做的共同工作**，我们称之为**前端 (Frontend)**。我们把前端代码放在 `common` 里，这样三个子项目就可以直接拿来用，不用重复写三遍了。

## 4. 下一步是什么？

在下一篇文章中，我们将深入 `common` 文件夹，看看一段 BF 代码被读入程序后，是如何经历**词法分析**、**语法分析**，最终变成一个名为 **IR（中间表示）** 的数据结构的。

准备好进入真正写代码的环节了吗？我们下一篇见！
