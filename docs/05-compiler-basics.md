# 第五篇：编译器魔法——从代码到 EXE

这是本系列的最终篇。我们将挑战一个高难度也是最酷的任务：**写一个程序，让它生成另一个能直接双击运行的 Windows `.exe` 程序。**

在这个过程中，我们**不使用任何外部工具**（没有 gcc，没有 g++，没有汇编器，没有链接器）。我们要像《黑客帝国》里的造物主一样，直接向硬盘写入二进制字节。

---

## 1. 机器码：CPU 的唯一母语

你写的 C++ 代码（`int a = 1;`），或者汇编代码（`add rax, 1`），CPU 都是看不懂的。CPU 只认识一种东西：**高低电平的信号**，也就是 0 和 1 组成的数字序列，我们称之为**机器码 (Machine Code)**。

比如，在 64 位 Intel/AMD CPU (x86-64 架构) 上：
*   你想让寄存器 `rbx` 的值加 1。
*   你需要发给 CPU 的机器码是：`48 FF C3`（十六进制）。

### 什么是寄存器？
你可以把**内存**想象成一个巨大的带编号的储物柜，存取东西比较慢。
而**寄存器 (Register)** 是 CPU 内部自带的几个极其珍贵的小草稿纸，存取速度快如闪电。

在我们的编译器中，我们指定了一个专属草稿纸：**`rbx` 寄存器**。
我们让 `rbx` 永远记录当前内存带（Tape）的地址。这样一来，BF 的指令就可以直接翻译成极其高效的机器码：

*   `>` (指针右移一格)：对应 `inc rbx`，机器码是 `48 FF C3`。
*   `<` (指针左移一格)：对应 `dec rbx`，机器码是 `48 FF CB`。
*   `SetZero` (当前格子清零)：对应 `mov byte [rbx], 0`，意思是"把 `rbx` 指向的那个储物柜里清空"，机器码是 `C6 03 00`。

你看，把 IR 变成机器码，其实就是**查字典翻译**。我们在 `pe_codegen.h` 中就是用一堆 `c.u8(0x48); c.u8(0xFF); c.u8(0xC3);` 这样的代码，把机器码一个字节一个字节地塞进数组里。

---

## 2. 只有机器码能跑吗？

假设我们现在已经把 `[ 48, FF, C3, C6, ... ]` 这一大串机器码算出来了，直接把它存成文件，双击能运行吗？

**绝对不能！**

Windows 系统会跳出来报错："这是什么垃圾文件？我看不懂！"
为什么？因为 Windows 作为一个操作系统（管理员），它需要知道这个文件的基本信息才能给它分配资源：
*   "这文件是在我 Windows 上跑的，还是在 Linux 上跑的？"
*   "这程序是 32 位的还是 64 位的？"
*   "机器码放在文件的哪个位置？"
*   "你要向系统申请多大的内存（Tape）？"
*   "你需要调用我的哪些系统功能（比如打印到屏幕）？"

只有把这些信息像**快递面单**一样贴在机器码的外面，Windows 才愿意接收并执行它。
这个带面单的快递盒，在 Windows 世界里就叫 **PE (Portable Executable) 文件格式**。也就是你天天见到的 `.exe` 文件。

---

## 3. PE 文件：Windows 的快递盒

PE 文件的结构非常严谨，但在我们的编译器里，我们只用了它最核心的几个部分。我们可以把 PE 文件想象成一栋三层楼的房子，加上一个屋顶。

### 屋顶：文件头 (Headers)
这里存放着最重要的元数据。
*   **DOS 头**：历史遗留问题，所有 `.exe` 开头的两个字母必须是 `MZ`。
*   **PE 签名**：告诉系统这是一个 PE 文件。
*   **程序入口点 (Entry Point)**：告诉 CPU："进门之后，直接去 0x1000 那个房间开始执行机器码！"

### 一楼：代码段 (`.text` Section)
这里存放的就是我们刚才辛辛苦苦翻译出来的**机器码**。
我们会告诉系统：这一层的属性是**"可读"且"可执行"**（不能被修改，防黑客）。

### 二楼：数据段 (`.data` Section)
程序运行需要内存。我们在这一层申请了 30000 字节的空白空间，专门留给 BF 的 Tape 使用。
这一层的属性是**"可读"且"可写"**（但不能执行）。

### 三楼：导入表 (`.idata` Section) —— 最神奇的魔法
BF 里有个 `.` 指令，要把字符印在屏幕上。但是，向屏幕画像素、调用显卡，这是操作系统（Windows）的特权，我们的机器码没资格直接干这事。

我们要怎么求 Windows 办事呢？我们需要调用 Windows 提供的 API 函数，比如管输出的函数叫 `WriteFile`。这个函数藏在 Windows 自己的一个文件 `kernel32.dll` 里。

**导入表就是我们要写给 Windows 的一封"介绍信"**：
1. 我们的 `.exe` 文件在导入表里写上："报告长官，我的程序启动时，请帮我把 `kernel32.dll` 里的 `WriteFile` 函数找出来。"
2. 留出一个空白的格子（叫做 IAT，导入地址表）。
3. 当你双击运行这个 `.exe` 时，Windows 会看到这封信，然后在自己的系统里找到 `WriteFile` 的真实内存地址，**填进我们留出的那个空白格子 (IAT) 里**。
4. 当我们的机器码执行到打印指令时，只要去那个格子里拿地址，就能成功呼叫 Windows 帮忙打印了！

这套机制在我们的代码 `pe_writer.cpp` 中被完美地徒手复刻了。

---

## 4. 两遍编译：先量尺寸，再做衣服

在打包这栋"三层楼"时，我们遇到了一个经典的"先有鸡还是先有蛋"的问题：
1. 机器码里的某些指令，需要知道数据段（Tape）在内存中的准确地址（这叫 RIP 相对寻址）。
2. 但是，数据段排在代码段的后面。代码段到底有多长，取决于我们生成了多少机器码。
3. 所以，**不生成完机器码，就不知道数据段的地址；不知道数据段的地址，就生成不了正确的机器码。**

怎么办？老裁缝教你：**量体裁衣，做两遍**。

*   **第一遍（假装生成）**：我们先随便瞎猜一个数据段的地址，让程序先把所有的机器码假装生成一遍。生成完之后，我们数一数："哦！原来机器码一共占了 438 个字节！"
*   **排版**：既然知道了代码长度，我们就能精确算出数据段和导入表在内存中的完美位置。
*   **第二遍（动真格）**：清空第一次生成的垃圾。带着刚才算出来的完美地址，重新生成一遍机器码。这一次，所有的地址跳转都严丝合缝、分毫不差。

这段逻辑在代码中长这样：
```cpp
// 第一遍：瞎猜一个地址，为了知道代码到底有多长
pe::CodeBuf dummy;
pe::gen_code(program, dummy, text_rva, est_iat_rva, est_data_rva);
uint32_t code_size = dummy.size(); 

// 此时根据 code_size，我们可以算出真正的地址了！
idata_rva = text_rva + align_up(code_size, 4096);
data_rva  = idata_rva + align_up(idata_size, 4096);

// 第二遍：用真正的地址，生成最终的完美机器码
pe::CodeBuf code;
pe::gen_code(program, code, text_rva, real_iat_rva, data_rva);
```

最后，我们用 C++ 的 `std::ofstream`，把文件头、代码段、导入表、数据段，按照对齐规则，像俄罗斯方块一样一个个拼接好，写入硬盘后缀名为 `.exe` 的文件里。

大功告成！

---

## 5. 结语

恭喜你看到了这里！回顾一下我们做了什么：
1. 我们手写了 Lexer 和 Parser，把字符变成了聪明的结构体（IR）。
2. 我们写了 Optimizer，把上万条冗余指令压缩成了几千条。
3. 我们写了解释器，用 C++ 模拟了 CPU 的运行。
4. 我们写了转译器，借用 C 语言实现了程序的降维打击。
5. 我们甚至直接查字典写出了机器码，并手捏了 Windows 的 PE 格式快递盒，不靠任何第三方工具生成了真正的 `.exe`！

虽然 Brainfuck 是一门用来娱乐的语言，但通过这个项目，你已经走过了一个现代编译器（如 GCC、Clang、MSVC）**所有的核心工作流程**。

下次当你在 IDE 里按下 "Run" 键，看着终端里闪出的黑底白字时，你会比以前更清楚地知道，在这短短的一秒钟里，你的电脑里发生了怎样波澜壮阔的魔法。

感谢阅读，祝你在底层开发的奇妙世界里玩得开心！
